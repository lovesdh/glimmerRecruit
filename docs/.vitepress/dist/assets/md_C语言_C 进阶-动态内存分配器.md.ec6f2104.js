import{_ as o,o as e,c as l,Q as c}from"./chunks/framework.e90f0c97.js";const E=JSON.parse('{"title":"C 进阶 动态内存分配器","description":"","frontmatter":{},"headers":[],"relativePath":"md/C语言/C 进阶-动态内存分配器.md","filePath":"md/C语言/C 进阶-动态内存分配器.md"}'),a={name:"md/C语言/C 进阶-动态内存分配器.md"},s=c(`<p><img src="https://pic.imgdb.cn/item/64c4a2881ddac507cc007975.png" alt=""></p><h1 id="c-进阶-动态内存分配器" tabindex="-1">C 进阶 动态内存分配器 <a class="header-anchor" href="#c-进阶-动态内存分配器" aria-label="Permalink to &quot;C 进阶 动态内存分配器&quot;">​</a></h1><blockquote><p>相信大家都使用过<code>malloc</code>和<code>free</code>函数显式的分配内存，这两个函数分配一个称为堆的内存，那么，他们是怎么管理堆的内存的呢？c标准库提供一个叫做<code>malloc</code>程序包的显示分配器，通过这个包来管理堆，现在，让我们用c程序来编写一个动态内存分配器，也就是实现你自己的<code>malloc</code>,<code>free</code>,<code>realloc</code>函数。</p></blockquote><h2 id="准备步骤" tabindex="-1">准备步骤 <a class="header-anchor" href="#准备步骤" aria-label="Permalink to &quot;准备步骤&quot;">​</a></h2><p>在<code>linux</code>环境下编写，首先，先配置环境</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">sudo</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">apt</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">update</span></span>
<span class="line"><span style="color:#B392F0;">sudo</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">apt-get</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">install</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">gcc-multilib</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">g++-multilib</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">sudo</span><span style="color:#24292E;"> </span><span style="color:#032F62;">apt</span><span style="color:#24292E;"> </span><span style="color:#032F62;">update</span></span>
<span class="line"><span style="color:#6F42C1;">sudo</span><span style="color:#24292E;"> </span><span style="color:#032F62;">apt-get</span><span style="color:#24292E;"> </span><span style="color:#032F62;">install</span><span style="color:#24292E;"> </span><span style="color:#032F62;">gcc-multilib</span><span style="color:#24292E;"> </span><span style="color:#032F62;">g++-multilib</span></span></code></pre></div><p>然后</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">git</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">clone</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">https://github.com/9LLPPLL6/c</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">git</span><span style="color:#24292E;"> </span><span style="color:#032F62;">clone</span><span style="color:#24292E;"> </span><span style="color:#032F62;">https://github.com/9LLPPLL6/c</span></span></code></pre></div><p>克隆成功后，先执行</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">make</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">clean</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">make</span><span style="color:#24292E;"> </span><span style="color:#032F62;">clean</span></span></code></pre></div><p>然后就可以愉快的敲代码了。</p><h2 id="简单了解一下内存分配器" tabindex="-1">简单了解一下内存分配器 <a class="header-anchor" href="#简单了解一下内存分配器" aria-label="Permalink to &quot;简单了解一下内存分配器&quot;">​</a></h2><p>学<code>c语言</code>最让人头大的是指针以及让人心跳骤停的<code>segmentation fault</code>,这道题就让我们直面恐惧，让我们试试管理内存，想一想，为什么我们使用<code>malloc</code>就可以得到一个可以使用的内存块，如果不<code>free</code>就会内存泄漏，里面的内存是怎么管理的，怎么知道有空闲的块可以分配给我们，怎么知道满了，没有可以分配的空闲块了，其实，这可以由空闲链表来进行管理记录，每次要分配的时候就在空闲链表里面寻找合适的块，找到了就把这个块从空闲链表删除，并分配出去，释放块的时候，把这个块加入空闲链表，其中也涉及一些策略，比如，分配块的时候，找到的空闲块的大小比请求的大小大，那么剩余的部分将如何处理，一起分配出去还是分割独立变成一个空闲块，释放块的时候，前后的块是否为空闲块，是否要合并，何时合并都是要考虑的问题。</p><p>一个空闲块的常见结构如下：</p><p><img src="https://pic1.zhimg.com/70/v2-44ee15ae9dc4eab7d75b91c5366bccdd_1440w.image?source=172ae18b&amp;biz_tag=Post" alt="CSAPP | Lab8-Malloc Lab 深入解析"></p><p>前面四个字节是头部，<code>block size</code>记录的是块大小，头部的四个字节的最低位标记是否分配，通过<code>block size</code>就可以知道到下一个块的起始地址，这样，块之间就形成了一个隐式链表，头部下面是有效负载，也就是<code>malloc</code>请求的大小，再往下是为了对齐要求的填充字节，最后是脚部，便于空闲块合并前面的空闲块。</p><p>空闲块怎么组织呢？</p><p><img src="https://pic2.zhimg.com/v2-b9cfe142c46c0f10604d29ed36beea19_r.jpg" alt="img"></p><p>首先前面是为了对齐的填充，然后由一个序言块（一个头部，一个脚部）构成，后面是空闲链表，最后是结尾块（一个大小为零的头部），为了合并时不用考虑边界，把序言块和结尾块设置为已分配，这样，就是一个简单的动态内存分配器了。</p><h2 id="如何编写" tabindex="-1">如何编写 <a class="header-anchor" href="#如何编写" aria-label="Permalink to &quot;如何编写&quot;">​</a></h2><p>动态内存分配器将由以下四个函数组成（你可以定义静态函数，在这四个函数中调用），它们在<code>mm.h</code>中声明，在<code>mm.c</code>中定义，函数声明如下：</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mm_init</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">void*</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mm_malloc</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mm_free</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">void*</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">void*</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">mm_realloc</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">void*</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">size_t</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mm_init</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">void</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">void*</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mm_malloc</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mm_free</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">void*</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">void*</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">mm_realloc</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">void*</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">size_t</span><span style="color:#24292E;">);</span></span></code></pre></div><ul><li><code>mm_init</code>:在调用<code>mm_malloc</code> <code>mm_realloc</code> 或<code>mm_free</code> 之前，应用程序(即用于评估的程序)调用<code>mm_init</code> 来执行初始化，比如分配初始堆区域。如果初始化过程中出现问题，返回值应该为<code>-1</code>，否则为<code>0</code>.</li><li><code>mm_malloc(size_t size)</code>: 该函数返回一个指向至少<code>size</code>字节有效负载的已分配块的指针。整个分配的块应该位于堆区域内，不应该与任何其他分配的块重叠，返回8字节对齐的指针.</li><li><code>mm_free(void* ptr)</code>:该函数释放<code>ptr </code>指向的块。它不会返回任何东西。如果<code>ptr</code>指向的块为未分配，测试程序会报错。</li><li><code>mm_realloc(void* ptr,size_t size)</code>:该函数返回指向至少<code>size</code>字节的分配区域的指针,并满足下列行为 <ul><li>如果<code>ptr</code>为<code>NULL</code>，则调用等价于<code>mm_malloc(size)</code>.</li><li>如果<code>size</code>为零，则调用等价于<code>mm_free(ptr)</code>.</li><li>如果<code>ptr</code> 不是<code>NULL</code>，那么它一定是指向已分配块的。调用<code>mm_realloc </code>将<code>ptr </code>(旧块)指向的内存块的大小改为指定大小即<code>(size)</code>，并返回新块的地址。注意，新块的地址可以与旧块相同，也可以不同，这取决于您的实现、旧块中内部碎片的数量以及<code>mm_realloc</code> 请求的大小.新块的内容与<code>ptr</code>旧块的内容相同，其他的都是未初始化的。例如，如果旧块是8个字节，新块是12个字节，那么新块的前8个字节与旧块前8个字节相同,新块最后4个字节是未初始化的。同样，如果旧块为8字节，新块为4字节，则新块的内容与旧块的前4字节相同，旧块的后四个字节将舍弃。</li><li>这些语义与相应的<code>libc 的 malloc realloc free </code>的语义相匹配。</li></ul></li></ul><p><code>memlib.c</code>包模拟了动态内存分配器的内存系统。你可以在<code>memlib.c</code>中调用以下函数：</p><ul><li><code>void* mem_sbrk(int incr)</code>:通过<code>incr </code>字节扩展堆，其中<code>incr </code>是一个正整数，并返回一个<code>void</code>的指针，指向新分配的堆区域的第一个字节。其语义与<code>Unix sbrk </code>函数相同，只是<code>mem_sbrk </code>只接受一个正整数参数.</li><li><code>void* mem_heap_lo(void)</code>:返回一个指向堆中第一个字节的通用指针.</li><li><code>void* mem_heap_hi(void)</code>:返回指向堆中最后一个字节的通用指针。</li><li><code>size_t mem_heapsize(void)</code>：返回堆的当前大小(以字节为单位)。</li><li><code>size_t mem_pagesize(void)</code>：返回系统的页面大小(以字节为单位)(<code>Linux</code> 系统上为<code>4k</code>)。</li></ul><h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h3><ul><li>不要修改<code>mm.c</code> 中的任何接口.</li><li>不要调用任何与内存管理相关的库调用或系统调用,即不要使用<code>malloc，calloc，free，realloc，sbrk，brk </code>或者这些调用的变体.</li><li>不要在<code>mm.c </code>程序中定义任何全局或静态复合数据结构，如数组、结构、树。但是，你可以在<code>mm.c </code>中声明全局变量，如整数、浮点数和指针</li><li>该分配器返回按8字节边界对齐的块，分配器必须始终返回按8字节边界对齐的指针。测试程序会测试这个要求.</li></ul><h2 id="评估" tabindex="-1">评估 <a class="header-anchor" href="#评估" aria-label="Permalink to &quot;评估&quot;">​</a></h2><p><code>mdriver.c</code>测试<code>mm.c</code>,这个测试程序由一组跟踪文件控制，每个跟踪文件包含一个序列，<code>mdriver.c</code>接受以下命令行参数：</p><ul><li><code>-t&lt;tracedir&gt;</code>:查找<code>tracedir</code> 目录中的默认跟踪文件，而不是<code>config.h</code> 中定义的默认目录,在<code>config.h</code>中，<code>#define TRACEDIR &quot;traces/&quot;</code>定义了默认跟踪文件的路径。</li><li><code>-f &lt;tracefile&gt;</code>:使用一个特定的跟踪文件代替默认的跟踪文件集进行测试。</li><li><code>-h</code>:打印命令行参数的摘要.</li><li><code>-v</code>:详细输出。打印每个跟踪文件的性能信息.</li><li><code>-V</code>:更详细的输出。在处理每个跟踪文件时打印额外的测试信息。在调试过程中，用于确定哪个跟踪文件导致失败。</li></ul><p>如果你程序有错或者违反了上面说明的规则，你将得到零分.如果你的分配器是正确的，将按以下方式计算得分:</p><ul><li>正确性。如果你的解决方案通过了测试程序的正确性测试，你将获得这部分的满分。</li><li>性能。两个性能指标将用于测试你的分配器 <ul><li>空间利用率<code>(util)</code>: 测试程序使用的内存总量(即已分配的内存总量)与分配程序使用的堆大小之间的比值。最佳比率等于1。你应该找到好的政策来尽量减少碎片来使这个比率尽可能接近最优</li><li>吞吐量<code>(thru)</code>: 平均每秒完成的操作数。</li></ul></li></ul><h2 id="文件说明" tabindex="-1">文件说明 <a class="header-anchor" href="#文件说明" aria-label="Permalink to &quot;文件说明&quot;">​</a></h2><ul><li><code>traces</code>：用于评估的跟踪文件</li><li><code>mm.c</code>：你的工作文件</li><li><code>memlib.c</code>:模拟了动态内存分配器的内存系统</li><li><code>mdriver.c</code>:测试文件</li></ul><h2 id="提示" tabindex="-1">提示 <a class="header-anchor" href="#提示" aria-label="Permalink to &quot;提示&quot;">​</a></h2><ul><li><p>使用<code>mdriver -f</code> 选项。在开始的做题过程中，使用小的跟踪文件可以简化调试。我们已经包含了两个这样的跟踪文件<code>(short1,2-bal.Rep) </code>，可用于初始调试。</p></li><li><p>使用<code>mdriver -v </code>和<code>-V</code> 选项。<code>V</code> 选项会为每个跟踪文件提供一个详细的信息。<code>V</code> 还会显示每个跟踪文件的读取时间，这将帮助你分析错误。</p></li><li><p>使用<code> gcc -g</code> 编译并使用调试器<code>gdb</code>。一个调试器可以帮助你分析超出范围的内存引用。</p></li><li><p>注意指针的强制类型转换，使用类函数宏计算块大小，计算块是否分配等等</p></li><li><p>分阶段进行实现。前9个跟踪文件包含对<code>malloc </code>和<code>free </code>的请求。最后两个跟踪包含<code>realloc、malloc 和free </code>的请求。建议你从让<code>malloc </code>和<code>free </code>在前9个跟踪中正确执行开始。这样，你才能将注意力转移到<code>realloc </code>的实现上。你可以用<code>malloc</code>和<code>free</code>实现<code>realloc</code>,但是为了性能为了更高的分数，应该进行逻辑判断，分情况进行操作。</p></li><li><p><code>mm.c中的printf函数</code>会对性能产生影响,在测试之前把可能用于调试的<code>printf</code>注释。</p></li><li><p>编译过程遇到<code>warning</code>，如果不是<code>mm.c</code>的，可以忽略。</p></li><li><p>建议阅读<code>csapp</code>第九章的后半部分。（强烈推荐）</p></li></ul><h2 id="需要提交的内容及要求" tabindex="-1">需要提交的内容及要求 <a class="header-anchor" href="#需要提交的内容及要求" aria-label="Permalink to &quot;需要提交的内容及要求&quot;">​</a></h2><ul><li>可以描述一下解题过程中遇到的困难以及如何解决的，描述一下动态内存分配器的设计思路</li><li>提交<code>mm.c</code>文件的源代码</li><li>良好的代码习惯，例如适当的注释，每个文件开头都应该添加注释说明该文件的内容和作用（加分🥰）</li><li>请提交PDF文档</li></ul><h2 id="本题提交方式" tabindex="-1">本题提交方式 <a class="header-anchor" href="#本题提交方式" aria-label="Permalink to &quot;本题提交方式&quot;">​</a></h2><blockquote><p>收件邮箱：<a href="mailto:glimmer401@outlook.com" target="_blank" rel="noreferrer">glimmer401@outlook.com</a></p><p>主题格式： 学号-姓名-考核-C-malloc</p><p>主题示例：2024090101012-张三-考核-C-malloc</p></blockquote><h2 id="出题人联系方式" tabindex="-1">出题人联系方式 <a class="header-anchor" href="#出题人联系方式" aria-label="Permalink to &quot;出题人联系方式&quot;">​</a></h2><blockquote><p>QQ:239148349</p><p>邮箱：LLP_PLL@outlook.com</p></blockquote>`,42),p=[s];function n(d,i,t,r,m,h){return e(),l("div",null,p)}const u=o(a,[["render",n]]);export{E as __pageData,u as default};

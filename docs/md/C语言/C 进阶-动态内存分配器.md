![](https://pic.imgdb.cn/item/64c4a2881ddac507cc007975.png)



# C 进阶 动态内存分配器

> 相信大家都使用过`malloc`和`free`函数显式的分配内存，这两个函数分配一个称为堆的内存，那么，他们是怎么管理堆的内存的呢？c标准库提供一个叫做`malloc`程序包的显示分配器，通过这个包来管理堆，现在，让我们用c程序来编写一个动态内存分配器，也就是实现你自己的`malloc`,`free`,`realloc`函数。

## 准备步骤

在`linux`环境下编写，首先，先配置环境

```sh
sudo apt update
sudo apt-get install gcc-multilib g++-multilib
```

然后

```sh
git clone https://github.com/9LLPPLL6/c
```

克隆成功后，先执行

```sh
make clean
```

然后就可以愉快的敲代码了。



## 简单了解一下内存分配器

学`c语言`最让人头大的是指针以及让人心跳骤停的`segmentation fault`,这道题就让我们直面恐惧，让我们试试管理内存，想一想，为什么我们使用`malloc`就可以得到一个可以使用的内存块，如果不`free`就会内存泄漏，里面的内存是怎么管理的，怎么知道有空闲的块可以分配给我们，怎么知道满了，没有可以分配的空闲块了，其实，这可以由空闲链表来进行管理记录，每次要分配的时候就在空闲链表里面寻找合适的块，找到了就把这个块从空闲链表删除，并分配出去，释放块的时候，把这个块加入空闲链表，其中也涉及一些策略，比如，分配块的时候，找到的空闲块的大小比请求的大小大，那么剩余的部分将如何处理，一起分配出去还是分割独立变成一个空闲块，释放块的时候，前后的块是否为空闲块，是否要合并，何时合并都是要考虑的问题。

一个空闲块的常见结构如下：

![CSAPP | Lab8-Malloc Lab 深入解析](https://pic1.zhimg.com/70/v2-44ee15ae9dc4eab7d75b91c5366bccdd_1440w.image?source=172ae18b&biz_tag=Post)

前面四个字节是头部，`block size`记录的是块大小，头部的四个字节的最低位标记是否分配，通过`block size`就可以知道到下一个块的起始地址，这样，块之间就形成了一个隐式链表，头部下面是有效负载，也就是`malloc`请求的大小，再往下是为了对齐要求的填充字节，最后是脚部，便于空闲块合并前面的空闲块。

空闲块怎么组织呢？

![img](https://pic2.zhimg.com/v2-b9cfe142c46c0f10604d29ed36beea19_r.jpg)

首先前面是为了对齐的填充，然后由一个序言块（一个头部，一个脚部）构成，后面是空闲链表，最后是结尾块（一个大小为零的头部），为了合并时不用考虑边界，把序言块和结尾块设置为已分配，这样，就是一个简单的动态内存分配器了。

## 如何编写

动态内存分配器将由以下四个函数组成（你可以定义静态函数，在这四个函数中调用），它们在`mm.h`中声明，在`mm.c`中定义，函数声明如下：

```c
int mm_init(void);
void* mm_malloc(size_t);
void mm_free(void*);
void* mm_realloc(void*,size_t);
```

* `mm_init`:在调用`mm_malloc` `mm_realloc` 或`mm_free` 之前，应用程序(即用于评估的程序)调用`mm_init` 来执行初始化，比如分配初始堆区域。如果初始化过程中出现问题，返回值应该为`-1`，否则为`0`.
* `mm_malloc(size_t size)`: 该函数返回一个指向至少`size`字节有效负载的已分配块的指针。整个分配的块应该位于堆区域内，不应该与任何其他分配的块重叠，返回8字节对齐的指针.
* `mm_free(void* ptr)`:该函数释放`ptr `指向的块。它不会返回任何东西。如果`ptr`指向的块为未分配，测试程序会报错。
* `mm_realloc(void* ptr,size_t size)`:该函数返回指向至少`size`字节的分配区域的指针,并满足下列行为
  * 如果`ptr`为`NULL`，则调用等价于`mm_malloc(size)`.
  *  如果`size`为零，则调用等价于`mm_free(ptr)`.
  * 如果`ptr` 不是`NULL`，那么它一定是指向已分配块的。调用`mm_realloc `将`ptr `(旧块)指向的内存块的大小改为指定大小即`(size)`，并返回新块的地址。注意，新块的地址可以与旧块相同，也可以不同，这取决于您的实现、旧块中内部碎片的数量以及`mm_realloc` 请求的大小.新块的内容与`ptr`旧块的内容相同，其他的都是未初始化的。例如，如果旧块是8个字节，新块是12个字节，那么新块的前8个字节与旧块前8个字节相同,新块最后4个字节是未初始化的。同样，如果旧块为8字节，新块为4字节，则新块的内容与旧块的前4字节相同，旧块的后四个字节将舍弃。
  * 这些语义与相应的`libc 的 malloc realloc free `的语义相匹配。

`memlib.c`包模拟了动态内存分配器的内存系统。你可以在`memlib.c`中调用以下函数：

* `void* mem_sbrk(int incr)`:通过`incr `字节扩展堆，其中`incr `是一个正整数，并返回一个`void`的指针，指向新分配的堆区域的第一个字节。其语义与`Unix sbrk `函数相同，只是`mem_sbrk `只接受一个正整数参数.
* `void* mem_heap_lo(void)`:返回一个指向堆中第一个字节的通用指针.
* `void* mem_heap_hi(void)`:返回指向堆中最后一个字节的通用指针。
* `size_t mem_heapsize(void)`：返回堆的当前大小(以字节为单位)。
* `size_t mem_pagesize(void)`：返回系统的页面大小(以字节为单位)(`Linux` 系统上为`4k`)。

### 注意

* 不要修改`mm.c` 中的任何接口.
* 不要调用任何与内存管理相关的库调用或系统调用,即不要使用`malloc，calloc，free，realloc，sbrk，brk `或者这些调用的变体.
* 不要在`mm.c `程序中定义任何全局或静态复合数据结构，如数组、结构、树。但是，你可以在`mm.c `中声明全局变量，如整数、浮点数和指针
* 该分配器返回按8字节边界对齐的块，分配器必须始终返回按8字节边界对齐的指针。测试程序会测试这个要求.

## 评估

`mdriver.c`测试`mm.c`,这个测试程序由一组跟踪文件控制，每个跟踪文件包含一个序列，`mdriver.c`接受以下命令行参数：

* `-t<tracedir>`:查找`tracedir` 目录中的默认跟踪文件，而不是`config.h` 中定义的默认目录,在`config.h`中，`#define TRACEDIR "traces/"`定义了默认跟踪文件的路径。
* `-f <tracefile>`:使用一个特定的跟踪文件代替默认的跟踪文件集进行测试。
* `-h`:打印命令行参数的摘要.
* `-v`:详细输出。打印每个跟踪文件的性能信息.
* `-V`:更详细的输出。在处理每个跟踪文件时打印额外的测试信息。在调试过程中，用于确定哪个跟踪文件导致失败。

如果你程序有错或者违反了上面说明的规则，你将得到零分.如果你的分配器是正确的，将按以下方式计算得分:

* 正确性。如果你的解决方案通过了测试程序的正确性测试，你将获得这部分的满分。
* 性能。两个性能指标将用于测试你的分配器
  * 空间利用率`(util)`: 测试程序使用的内存总量(即已分配的内存总量)与分配程序使用的堆大小之间的比值。最佳比率等于1。你应该找到好的政策来尽量减少碎片来使这个比率尽可能接近最优
  * 吞吐量`(thru)`: 平均每秒完成的操作数。

## 文件说明

* `traces`：用于评估的跟踪文件
* `mm.c`：你的工作文件
* `memlib.c`:模拟了动态内存分配器的内存系统
* `mdriver.c`:测试文件

## 提示

* 使用`mdriver -f` 选项。在开始的做题过程中，使用小的跟踪文件可以简化调试。我们已经包含了两个这样的跟踪文件`(short1,2-bal.Rep) `，可用于初始调试。

* 使用`mdriver -v `和`-V` 选项。`V` 选项会为每个跟踪文件提供一个详细的信息。`V` 还会显示每个跟踪文件的读取时间，这将帮助你分析错误。

* 使用` gcc -g` 编译并使用调试器`gdb`。一个调试器可以帮助你分析超出范围的内存引用。

* 注意指针的强制类型转换，使用类函数宏计算块大小，计算块是否分配等等

* 分阶段进行实现。前9个跟踪文件包含对`malloc `和`free `的请求。最后两个跟踪包含`realloc、malloc 和free `的请求。建议你从让`malloc `和`free `在前9个跟踪中正确执行开始。这样，你才能将注意力转移到`realloc `的实现上。你可以用`malloc`和`free`实现`realloc`,但是为了性能为了更高的分数，应该进行逻辑判断，分情况进行操作。

* `mm.c中的printf函数`会对性能产生影响,在测试之前把可能用于调试的`printf`注释。

* 编译过程遇到`warning`，如果不是`mm.c`的，可以忽略。

* 建议阅读`csapp`第九章的后半部分。（强烈推荐）

  

  

## 需要提交的内容及要求

* 可以描述一下解题过程中遇到的困难以及如何解决的，描述一下动态内存分配器的设计思路
* 提交`mm.c`文件的源代码
* 良好的代码习惯，例如适当的注释，每个文件开头都应该添加注释说明该文件的内容和作用（加分🥰）
* 请提交PDF文档

## 本题提交方式

> 收件邮箱：[glimmer401@outlook.com](mailto:glimmer401@outlook.com)
>
> 主题格式： 学号-姓名-考核-C-malloc
>
> 主题示例：2024090101012-张三-考核-C-malloc

## 出题人联系方式

> QQ:239148349
>
> 邮箱：LLP_PLL@outlook.com

